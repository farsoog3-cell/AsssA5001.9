<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Molfa Embroidery โ Stitches Output (ูุญุณูู)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root { --bg:#f3f4f6; --card:#ffffff; }
  body{font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:var(--bg); color:#111;}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;}
  .svg-preview img{ max-width:100%; height:auto; display:block; margin:0 auto; object-fit:contain; }
  .svg-wrap { width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
  .svg-wrap svg, .svg-wrap object { width:100%; height:100%; }
  /* small responsive adjustments */
  @media (max-width:640px){
    header h1{ font-size:1.05rem; }
    .grid-cols-3 { grid-template-columns: 1fr; }
  }
</style>
</head>
<body class="min-h-screen flex flex-col">
<header class="bg-indigo-700 text-white py-4 shadow text-center">
  <h1 class="text-xl md:text-2xl font-semibold">Molfa Embroidery โ ุชุญููู ุตูุฑุฉ โ ุบุฑุฒ</h1>
  <p class="text-sm">ูุณุฎุฉ ูุญุณููุฉ: ุฏุนู ุงูููุจุงููุ ุจุฏูู OffscreenCanvasุ ุชุตุฏูุฑ PNG/SVG/DST ุชุฌุฑูุจู</p>
</header>

<main class="container mx-auto p-4 md:p-6 flex-grow">
  <div class="bg-white rounded-xl shadow p-4 md:p-6 space-y-4">
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <!-- Controls -->
      <div class="space-y-3">
        <label class="block font-medium">ุงุฎุชุฑ ุตูุฑุฉ</label>
        <input id="file" type="file" accept="image/*" class="w-full p-2 border rounded"/>

        <div class="mt-3 grid grid-cols-2 gap-3 text-sm">
          <div>
            <label>ุนุฏุฏ ุงูุฃููุงู</label>
            <input id="colors" type="number" value="4" min="1" max="12" class="w-full p-2 border rounded"/>
          </div>
          <div>
            <label>ุนุฑุถ ุงููุนุงููุฉ (px)</label>
            <input id="previewW" type="number" value="700" min="200" max="1600" class="w-full p-2 border rounded"/>
          </div>
          <div>
            <label>ุทูู ุงูุบุฑุฒุฉ (px)</label>
            <input id="stitchLen" type="number" value="4" min="1" max="40" class="w-full p-2 border rounded"/>
          </div>
          <div>
            <label>ุชุจุงุนุฏ ุงูุบุฑุฒ (px)</label>
            <input id="stitchGap" type="number" value="4" min="1" max="40" class="w-full p-2 border rounded"/>
          </div>
          <div>
            <label>ุฒุงููุฉ ุงูุบุฑุฒ (ยฐ)</label>
            <input id="angle" type="number" value="45" min="0" max="180" class="w-full p-2 border rounded"/>
          </div>
          <div>
            <label>ุชุจุณูุท ุงููุณุงุฑุงุช (epsilon)</label>
            <input id="simplify" type="number" value="0.6" step="0.1" min="0" max="10" class="w-full p-2 border rounded"/>
          </div>
        </div>

        <div class="mt-3">
          <label class="block text-sm mb-1">ููุท ุงูุบุฑุฒ ุงูุนุงู</label>
          <select id="stitchMode" class="w-full p-2 border rounded">
            <option value="fill">Fill โ ุชุนุจุฆุฉ (ุฃูุถู ููููุงุทู ุงููุจูุฑุฉ)</option>
            <option value="satin">Satin โ ุณุงุชุงู (ุฃูุถู ููุญูุงู ูุงููุตูุต)</option>
          </select>
        </div>

        <div class="mt-2">
          <label class="block text-sm mb-1">ูููุงุณ ุงูุชุตุฏูุฑ (px โ 0.1mm)</label>
          <input id="exportScale" type="number" value="1.0" step="0.1" min="0.1" max="10" class="w-full p-2 border rounded"/>
          <div class="text-xs text-gray-500 mt-1">ุถุจุท ุนูุฏ ุชุญููู ููุฅุญุฏุงุซูุงุช ุงูุญููููุฉ. ุงููููุฉ 1 ุชุนูู 1px = 0.1mm.</div>
        </div>

        <div class="mt-3">
          <label class="block text-sm mb-1">ุดูุงููุฉ ุงูุฎูููุฉ ุฎูุงู ุงููุนุงููุฉ</label>
          <input id="bgOpacity" type="range" min="0" max="100" value="30" class="w-full"/>
          <div class="text-xs text-gray-500 mt-1">ุงุฌุนู ุงูุฎูููุฉ ุฃุนูู ูุชุฑู ุงูุชุทุงุจู ุจุฏูุฉ</div>
        </div>

        <div class="mt-3 flex flex-col sm:flex-row gap-3">
          <button id="process" class="flex-1 bg-indigo-600 text-white py-2 rounded hover:bg-indigo-700">๐ง ุชูููุฏ ุงูุบุฑุฒ ููููุงุช</button>
          <button id="previewBtn" class="flex-1 bg-gray-200 text-gray-800 py-2 rounded hover:bg-gray-300">๐ ูุนุงููุฉ ููุท</button>
        </div>

        <div class="mt-3 flex flex-col sm:flex-row gap-3">
          <button id="downloadSvg" class="flex-1 bg-blue-600 text-white py-2 rounded hidden">โฌ๏ธ ุชุญููู SVG</button>
          <button id="downloadDst" class="flex-1 bg-green-600 text-white py-2 rounded hidden">โฌ๏ธ ุชุญููู DST</button>
          <button id="downloadDte" class="flex-1 bg-pink-600 text-white py-2 rounded hidden">โฌ๏ธ ุชุญููู DTE</button>
          <button id="downloadPng" class="flex-1 bg-gray-700 text-white py-2 rounded hidden">โฌ๏ธ ุชุญููู ูุนุงููุฉ PNG</button>
        </div>

        <div id="spinner" class="hidden mt-4 text-center">
          <svg class="animate-spin h-8 w-8 text-indigo-600 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v8H4z"></path>
          </svg>
          <p class="text-sm mt-2">ุฌุงุฑู ุงููุนุงูุฌุฉ โ ูุฐู ูุณุฎุฉ ูุญุณููุฉ ูุชูููุฑ ุฏูุฉ ุฃุนูู</p>
        </div>

        <p class="mt-3 text-xs text-gray-600 leading-relaxed">
          ููุงุญุธุฉ: ููุญุตูู ุนูู ุฃูุถู ูุชูุฌุฉ ุงุณุชุฎุฏู ุตูุฑ ุดุนุงุฑุงุช ุจุฎูููุฉ ุดูุงูุฉ ุฃู ุชุจุงูู ุนุงูู. ุจุนุฏ ุงูุชุตุฏูุฑ ุงูุชุญ ููู SVG ูู Ink/Stitch ุฃู Inkscape ูุชุญุณููุงุช ูุชูุฏูุฉ ุฃู ุงุฎุชุจุงุฑ ููู DST ุนูู ูุงูููุฉ ุงูุชุฑุงุถูุฉ.
        </p>
      </div>

      <!-- Preview & log -->
      <div class="md:col-span-2 space-y-3">
        <div class="bg-gray-50 p-3 rounded min-h-[260px] sm:min-h-[380px] flex items-center justify-center">
          <div id="svgPreview" class="svg-wrap w-full h-full text-gray-500">ูู ูุชู ุงูุชูููุฏ ุจุนุฏ</div>
        </div>

        <div class="bg-white p-3 rounded border">
          <div class="flex items-center justify-between">
            <h4 class="font-bold mb-2">ุณุฌู ุงููุนุงูุฌุฉ</h4>
            <button id="clearLog" class="text-xs text-indigo-600">ูุณุญ</button>
          </div>
          <pre id="log" class="mono text-xs h-40 overflow-auto whitespace-pre-wrap"></pre>
        </div>
      </div>
    </div>
  </div>
</main>

<canvas id="work" style="display:none"></canvas>

<script>
/* ----------------- Utilities ----------------- */
function log(msg){
  const el = document.getElementById('log');
  const t = new Date().toLocaleTimeString();
  el.textContent += `[${t}] ${msg}\n`;
  el.scrollTop = el.scrollHeight;
}
function clearLog(){ document.getElementById('log').textContent = ''; }
function showSpinner(){ document.getElementById('spinner').classList.remove('hidden'); }
function hideSpinner(){ document.getElementById('spinner').classList.add('hidden'); }
function forceDownload(blob, name){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  // revoke after short time
  setTimeout(()=> URL.revokeObjectURL(url), 2000);
}
function makeWorkerFromFunc(fn){
  const src = fn.toString();
  const blob = new Blob(['('+src+')()'], {type:'application/javascript'});
  return new Worker(URL.createObjectURL(blob));
}

/* ----------------- Worker (single-file) --------------- */
/* The worker code is largely same idea as your original but with:
   - fallback-friendly behavior (it runs in worker anyway),
   - improved export scaling (exportScale),
   - safer transfer of ArrayBuffers,
   - clearer logs. */
const worker = makeWorkerFromFunc(function workerScope(){
  function postLog(m){ try{ postMessage({type:'log', msg:m}); }catch(e){} }
  onmessage = async (ev) => {
    const msg = ev.data;
    if(msg.type !== 'process') return;
    try{
      postLog('ุนุงูู: ุจุฏุก ุงููุนุงูุฌุฉ');
      const { dataURL, settings } = msg;
      const colors = Math.max(1, Math.min(12, parseInt(settings.colors)||4));
      const previewW = Math.max(120, parseInt(settings.previewW)||600);
      const stitchLen = Math.max(1, parseInt(settings.stitchLen)||4);
      const stitchGap = Math.max(1, parseInt(settings.stitchGap)||4);
      const angle = parseFloat(settings.angle)||45;
      const simplify = parseFloat(settings.simplify)||0.6;
      const mode = settings.mode || 'fill';
      const bgOpacity = Math.max(0, Math.min(100, parseInt(settings.bgOpacity)||30)) / 100;
      const exportScale = parseFloat(settings.exportScale) || 1.0; // px -> 0.1mm

      // load image (createImageBitmap where available)
      let imgBitmap = null;
      try{
        const resp = await fetch(dataURL);
        const blob = await resp.blob();
        if(self.createImageBitmap){
          imgBitmap = await createImageBitmap(blob);
        } else {
          // fallback: draw to canvas via Image
          const img = await new Promise((res, rej) => {
            const i = new Image();
            i.onload = () => res(i);
            i.onerror = rej;
            i.src = dataURL;
          });
          // draw onto OffscreenCanvas / Canvas
          const c = new OffscreenCanvas(img.width, img.height);
          const cx = c.getContext('2d');
          cx.drawImage(img,0,0);
          imgBitmap = await createImageBitmap(c);
        }
      }catch(e){
        postLog('ุนุงูู: ูุดู ุชุญููู ุงูุตูุฑุฉ: ' + (e.message||e));
        postMessage({ error:'image load failed' });
        return;
      }

      // scale to previewW
      const scale = previewW / imgBitmap.width;
      const w = Math.max(1, Math.round(imgBitmap.width * scale));
      const h = Math.max(1, Math.round(imgBitmap.height * scale));

      // create canvas (OffscreenCanvas if available)
      let off;
      try{ off = new OffscreenCanvas(w,h); }
      catch(e){
        // in worker, OffscreenCanvas should be available; if not, fail gracefully
        postLog('ุนุงูู: OffscreenCanvas ุบูุฑ ูุชููุฑ ูู ูุฐุง ุงููุชุตูุญ/ุจูุฆุฉ ุงูุนุงูู');
        postMessage({ error:'OffscreenCanvas not supported in worker' });
        return;
      }
      const ctx = off.getContext('2d');
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(imgBitmap, 0, 0, w, h);

      postLog(`ุนุงูู: ุตูุฑุฉ ูููุงุณ ${w}x${h}`);

      const id = ctx.getImageData(0,0,w,h);
      const data = id.data;

      // simple quantize (k-means-ish) on sampled pixels
      postLog('ุนุงูู: ุชุฌุฒุฆุฉ ุงูุฃููุงู...');
      const samples = [];
      const stepY = Math.max(1, Math.floor(h/100));
      const stepX = Math.max(1, Math.floor(w/100));
      for(let y=0;y<h;y+=stepY){
        for(let x=0;x<w;x+=stepX){
          const i = (y*w + x)*4;
          samples.push([data[i], data[i+1], data[i+2]]);
        }
      }
      const k = colors;
      let centers = [];
      for(let i=0;i<k;i++) centers.push(samples[Math.floor(Math.random()*samples.length)].slice());
      for(let iter=0; iter<8; iter++){
        const sums = Array.from({length:k}, ()=>[0,0,0,0]);
        for(const s of samples){
          let best=0,bd=Infinity;
          for(let j=0;j<k;j++){
            const c = centers[j];
            const d = (s[0]-c[0])**2 + (s[1]-c[1])**2 + (s[2]-c[2])**2;
            if(d<bd){ bd=d; best=j; }
          }
          sums[best][0]+=s[0]; sums[best][1]+=s[1]; sums[best][2]+=s[2]; sums[best][3]+=1;
        }
        for(let j=0;j<k;j++){
          if(sums[j][3]>0){
            centers[j][0]=Math.round(sums[j][0]/sums[j][3]);
            centers[j][1]=Math.round(sums[j][1]/sums[j][3]);
            centers[j][2]=Math.round(sums[j][2]/sums[j][3]);
          }
        }
      }
      postLog('ุนุงูู: ุงูุชูุช ูุฑุงูุฒ ุงูุฃููุงู');

      // assign each pixel to center
      const seg = new Uint8Array(w*h);
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const i = (y*w + x)*4;
          const r=data[i], g=data[i+1], b=data[i+2];
          let best=0,bd=Infinity;
          for(let j=0;j<k;j++){
            const c = centers[j];
            const d = (r-c[0])**2 + (g-c[1])**2 + (b-c[2])**2;
            if(d<bd){ bd=d; best=j; }
          }
          seg[y*w + x] = best;
        }
      }
      postLog('ุนุงูู: ุฎุฑูุทุฉ ุงูุชูุณูู ุฌุงูุฒุฉ');

      // collect connected components per color (4-connected)
      function collectRegionsForIndex(ci){
        const visited = new Uint8Array(w*h);
        const regions = [];
        for(let y=0;y<h;y++){
          for(let x=0;x<w;x++){
            const idx = y*w + x;
            if(visited[idx] || seg[idx] !== ci) continue;
            const stack = [idx];
            visited[idx]=1;
            let minX=x, maxX=x, minY=y, maxY=y;
            const pts = [];
            while(stack.length){
              const cur = stack.pop();
              const cy = Math.floor(cur/w);
              const cx = cur - cy*w;
              pts.push([cx,cy]);
              if(cx<minX) minX=cx; if(cx>maxX) maxX=cx;
              if(cy<minY) minY=cy; if(cy>maxY) maxY=cy;
              const nbs = [cur-1, cur+1, cur-w, cur+w];
              for(const nb of nbs){
                if(nb < 0 || nb >= w*h) continue;
                if(visited[nb]) continue;
                if(seg[nb] === ci){
                  visited[nb]=1; stack.push(nb);
                }
              }
            }
            regions.push({pts, bbox:[minX,minY,maxX,maxY]});
          }
        }
        return regions;
      }

      // simple stitch generators (like before)
      postLog('ุนุงูู: ุชูููุฏ ุบุฑุฒ ููุฃููุงู...');
      const angleRad = (angle||0) * Math.PI/180;
      const cosA = Math.cos(angleRad), sinA = Math.sin(angleRad);

      function generateFillStitches(region){
        const mask = new Uint8Array(w*h);
        for(const p of region.pts) mask[p[1]*w + p[0]] = 1;
        const stitches = [];
        const corners = [[region.bbox[0],region.bbox[1]],[region.bbox[2],region.bbox[1]],[region.bbox[0],region.bbox[3]],[region.bbox[2],region.bbox[3]]];
        let minS=Infinity, maxS=-Infinity, minR=Infinity, maxR=-Infinity;
        for(const c of corners){
          const xr = c[0]*cosA - c[1]*sinA;
          const yr = c[0]*sinA + c[1]*cosA;
          if(xr<minR) minR=xr; if(xr>maxR) maxR=xr;
          if(yr<minS) minS=yr; if(yr>maxS) maxS=yr;
        }
        const gap = Math.max(1, stitchGap);
        for(let s = Math.floor(minS)-1; s<=Math.ceil(maxS)+1; s += gap){
          let run = [];
          for(let r = Math.floor(minR)-1; r<=Math.ceil(maxR)+1; r++){
            const x = Math.round(r*cosA + s*sinA);
            const y = Math.round(-r*sinA + s*cosA);
            if(x<0||y<0||x>=w||y>=h){
              if(run.length>1){
                for(let i=0;i<run.length;i+=Math.max(1, Math.round(stitchLen))){
                  stitches.push(run[i]);
                }
              }
              run=[];
              continue;
            }
            if(mask[y*w + x]){
              run.push([x,y]);
            } else {
              if(run.length>1){
                for(let i=0;i<run.length;i+=Math.max(1, Math.round(stitchLen))){
                  stitches.push(run[i]);
                }
              }
              run=[];
            }
          }
        }
        return stitches;
      }

      function generateSatinStitches(region){
        const mask = new Uint8Array(w*h);
        for(const p of region.pts) mask[p[1]*w + p[0]] = 1;
        const stitches = [];
        const [minX,minY,maxX,maxY] = region.bbox;
        const gap = Math.max(1, Math.round(stitchGap/1.5));
        let minR=Infinity, maxR=-Infinity, minS=Infinity, maxS=-Infinity;
        const corners = [[minX,minY],[maxX,minY],[minX,maxY],[maxX,maxY]];
        for(const c of corners){
          const xr = c[0]*cosA - c[1]*sinA;
          const yr = c[0]*sinA + c[1]*cosA;
          if(xr<minR) minR=xr; if(xr>maxR) maxR=xr;
          if(yr<minS) minS=yr; if(yr>maxS) maxS=yr;
        }
        for(let r = Math.floor(minR)-1; r<=Math.ceil(maxR)+1; r += Math.max(1, Math.round(stitchLen/1.5))){
          let stroke = [];
          for(let s = Math.floor(minS)-1; s<=Math.ceil(maxS)+1; s++){
            const x = Math.round(r*cosA + s*sinA);
            const y = Math.round(-r*sinA + s*cosA);
            if(x<0||y<0||x>=w||y>=h) continue;
            if(mask[y*w + x]) stroke.push([x,y]);
          }
          if(stroke.length>2){
            for(let i=0;i<stroke.length;i+=Math.max(1, Math.round(stitchLen/1))){
              stitches.push(stroke[i]);
            }
          }
        }
        return stitches;
      }

      const allColorStitches = [];
      for(let ci=0; ci<k; ci++){
        postLog(`ุนุงูู: ูุนุงูุฌุฉ ุงูููู ${ci+1}/${k} ...`);
        const regions = collectRegionsForIndex(ci);
        postLog(`ุนุงูู: ุนุฏุฏ ููุงุทู ูููู ${ci}: ${regions.length}`);
        let colorBlocks = [];
        for(const reg of regions){
          if(reg.pts.length < 8) continue;
          let pts = (mode==='fill') ? generateFillStitches(reg) : generateSatinStitches(reg);
          if(pts.length){
            colorBlocks.push({ci, pts});
            postLog(`ุนุงูู: ููุทูุฉ ุจุญุฌู ${reg.pts.length} ุชูุชุฌ ${pts.length} ุบุฑุฒ ุชูุฑูุจูุฉ`);
          }
        }
        if(colorBlocks.length) allColorStitches.push(...colorBlocks);
      }

      if(allColorStitches.length === 0){
        postLog('ุนุงูู: ูู ุชูููููุฏ ุบุฑุฒ โ ุฌุฑููุจ ุชูููู ุงูุฃููุงู ุฃู ุฒูุงุฏุฉ ุงูุฏูุฉ.');
        const emptySvg = `<svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}'><rect width='100%' height='100%' fill='white'/></svg>`;
        postMessage({ svg: emptySvg, dstBuffer: new ArrayBuffer(0), dteBuffer: new ArrayBuffer(0), pngBuffer: new ArrayBuffer(0), width:w, height:h, notes:'no-stitches' });
        return;
      }

      // flatten order color-by-color and create simple point list with jump markers
      const flattened = [];
      for(const block of allColorStitches){
        const pts = block.pts;
        if(pts.length === 0) continue;
        flattened.push([pts[0][0], pts[0][1], true, block.ci]);
        for(let i=1;i<pts.length;i++) flattened.push([pts[i][0], pts[i][1], false, block.ci]);
      }

      // reduce near duplicates
      const merged = [];
      for(const p of flattened){
        if(merged.length === 0) merged.push(p);
        else {
          const last = merged[merged.length-1];
          if(Math.hypot(last[0]-p[0], last[1]-p[1]) >= 1) merged.push(p);
        }
      }
      postLog(`ุนุงูู: ููุงุท ุบุฑุฒ ุจุนุฏ ุงูุฏูุฌ: ${merged.length}`);

      // Build a simple Tajima-like DST prototype (NOT full spec-complete).
      // We convert pixel coords to export units: px * exportScale => 0.1mm units expected.
      function toExportCoord(px){
        // return integer coordinate in machine units (0.1mm)
        return Math.round(px * exportScale);
      }

      function buildDstBytes(points, label){
        const header = new Uint8Array(512);
        const name = ('LA:' + (label||'MOLFA') + '\n').slice(0, 80);
        for(let i=0;i<name.length && i<512;i++) header[i] = name.charCodeAt(i);
        // body: sequence of triplets [dx_byte, dy_byte, flags] but our limited encoding:
        const body = [];
        let prevx = 0, prevy = 0;
        for(const p of points){
          const x = toExportCoord(p[0]);
          const y = toExportCoord(p[1]);
          const isJump = !!p[2];
          let dx = x - prevx, dy = y - prevy;
          // break into chunks that fit into signed bytes (-127..127)
          while(Math.abs(dx) > 127 || Math.abs(dy) > 127){
            const sx = Math.max(-127, Math.min(127, dx));
            const sy = Math.max(-127, Math.min(127, dy));
            body.push((sx & 0xFF), (sy & 0xFF), isJump ? 0x01 : 0x00);
            dx -= sx; dy -= sy;
            prevx += sx; prevy += sy;
          }
          body.push((dx & 0xFF), (dy & 0xFF), isJump ? 0x01 : 0x00);
          prevx = x; prevy = y;
        }
        body.push(0x00,0x00,0xF3);
        const arr = new Uint8Array(512 + body.length);
        arr.set(header,0);
        arr.set(new Uint8Array(body),512);
        return arr;
      }

      const dstArr = buildDstBytes(merged, 'MOLFA_DST');
      const dteArr = buildDstBytes(merged, 'MOLFA_DTE'); // prototype same encoding

      // Build SVG preview with original image and strokes overlay
      postLog('ุนุงูู: ุจูุงุก SVG ุงููุนุงููุฉ...');
      const palette = centers.map(c => `rgb(${c[0]},${c[1]},${c[2]})`);
      let svg = `<svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}' viewBox='0 0 ${w} ${h}'>`;
      svg += `<rect width='100%' height='100%' fill='white'/>`;
      svg += `<image href='${dataURL}' width='${w}' height='${h}' opacity='${bgOpacity}' preserveAspectRatio='xMidYMid slice' />`;

      for(const block of allColorStitches){
        const col = palette[block.ci] || '#000';
        svg += `<g stroke="${col}" stroke-linecap="round" stroke-linejoin="round" stroke-width="1">`;
        for(const p of block.pts){
          const x1 = p[0], y1 = p[1];
          const x2 = x1 + Math.cos(angleRad) * Math.max(1, Math.round(stitchLen/2));
          const y2 = y1 + Math.sin(angleRad) * Math.max(1, Math.round(stitchLen/2));
          svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" />`;
        }
        svg += `</g>`;
      }
      svg += `</svg>`;

      // create PNG from offscreen canvas (preview) to offer PNG download
      const pngBlob = await off.convertToBlob({type:'image/png', quality:0.92});

      postLog('ุนุงูู: ุงูุชูุช ุงููุนุงูุฌุฉ ุจูุฌุงุญ');
      // transfer ArrayBuffers for performance
      postMessage({ svg, dstBuffer: dstArr.buffer, dteBuffer: dteArr.buffer, pngBlob, width:w, height:h, notes:`colors=${k}, stitches=${merged.length}` },
                  [dstArr.buffer, dteArr.buffer]);
    }catch(err){
      postLog('ุนุงูู: ุฎุทุฃ ' + (err && err.message ? err.message : err));
      postMessage({ error: err && err.message ? err.message : String(err) });
    }
  };
});

/* ----------------- UI integration ----------------- */
const fileInput = document.getElementById('file');
const processBtn = document.getElementById('process');
const previewBtn = document.getElementById('previewBtn');
const svgPreview = document.getElementById('svgPreview');
const downloadSvgBtn = document.getElementById('downloadSvg');
const downloadDstBtn = document.getElementById('downloadDst');
const downloadDteBtn = document.getElementById('downloadDte');
const downloadPngBtn = document.getElementById('downloadPng');

const colorsInput = document.getElementById('colors');
const previewWInput = document.getElementById('previewW');
const stitchLenInput = document.getElementById('stitchLen');
const stitchGapInput = document.getElementById('stitchGap');
const angleInput = document.getElementById('angle');
const simplifyInput = document.getElementById('simplify');
const stitchModeInput = document.getElementById('stitchMode');
const bgOpacityInput = document.getElementById('bgOpacity');
const exportScaleInput = document.getElementById('exportScale');
const clearLogBtn = document.getElementById('clearLog');

let lastSvgBlob=null, lastDstBlob=null, lastDteBlob=null, lastPngBlob=null;

worker.onmessage = (ev) => {
  const data = ev.data;
  if(data.type === 'log'){ log('[worker] ' + data.msg); return; }
  if(data.error){ log('ุฎุทุฃ ูู ุงูุนุงูู: ' + data.error); hideSpinner(); return; }

  log('ุฅููุงุก: ' + (data.notes||'ุชู'));
  lastSvgBlob = new Blob([data.svg], {type:'image/svg+xml'});
  lastDstBlob = new Blob([data.dstBuffer], {type:'application/octet-stream'});
  lastDteBlob = new Blob([data.dteBuffer], {type:'application/octet-stream'});
  // png may come as blob only via main-thread (we used a blob in message on worker side)
  // if png not provided by transfer, try to generate from svg in main thread
  if(data.pngBlob){
    lastPngBlob = data.pngBlob;
  } else {
    lastPngBlob = null;
  }

  svgPreview.innerHTML = '';
  const url = URL.createObjectURL(lastSvgBlob);
  const wrapper = document.createElement('div');
  wrapper.style.width = '100%'; wrapper.style.height = '100%';
  wrapper.innerHTML = `<object type="image/svg+xml" data="${url}" style="width:100%; height:100%; display:block;"></object>`;
  svgPreview.appendChild(wrapper);

  downloadSvgBtn.classList.remove('hidden');
  downloadDstBtn.classList.remove('hidden');
  downloadDteBtn.classList.remove('hidden');
  if(lastPngBlob) downloadPngBtn.classList.remove('hidden');

  downloadSvgBtn.onclick = ()=> forceDownload(lastSvgBlob, 'molfa_pattern.svg');
  downloadDstBtn.onclick = ()=> forceDownload(lastDstBlob, 'molfa_pattern.dst');
  downloadDteBtn.onclick = ()=> forceDownload(lastDteBlob, 'molfa_pattern.dte');
  downloadPngBtn.onclick = ()=> lastPngBlob ? forceDownload(lastPngBlob, 'molfa_preview.png') : null;

  hideSpinner();
};

worker.onerror = (err) => {
  log('ุฎุทุฃ ูู ุงูุนุงูู: ' + (err && err.message ? err.message : err));
  hideSpinner();
};

clearLogBtn.addEventListener('click', ()=> clearLog());

async function readFileAsDataURL(file){
  return await new Promise((res, rej) => {
    const fr = new FileReader();
    fr.onload = e=> res(e.target.result);
    fr.onerror = rej;
    fr.readAsDataURL(file);
  });
}

processBtn.addEventListener('click', async ()=>{
  clearLog();
  const f = fileInput.files[0];
  if(!f){ alert('ุงุฎุชุฑ ุตูุฑุฉ ุฃููุงู'); return; }
  showSpinner();
  try{
    const dataURL = await readFileAsDataURL(f);
    const settings = {
      colors: colorsInput.value,
      previewW: previewWInput.value,
      stitchLen: stitchLenInput.value,
      stitchGap: stitchGapInput.value,
      angle: angleInput.value,
      simplify: simplifyInput.value,
      mode: stitchModeInput.value,
      bgOpacity: bgOpacityInput.value,
      exportScale: exportScaleInput.value
    };
    log('ุฅุฑุณุงู ููุนุงูู: ' + JSON.stringify(settings));
    worker.postMessage({ type:'process', dataURL, settings });
  }catch(e){
    log('ุฎุทุฃ ูุฑุงุกุฉ ุงูููู: ' + e);
    hideSpinner();
  }
});

previewBtn.addEventListener('click', async ()=>{
  // same as process (we produce same outputs but user can choose not to save)
  clearLog();
  const f = fileInput.files[0];
  if(!f){ alert('ุงุฎุชุฑ ุตูุฑุฉ ุฃููุงู'); return; }
  showSpinner();
  try{
    const dataURL = await readFileAsDataURL(f);
    const settings = {
      colors: colorsInput.value,
      previewW: previewWInput.value,
      stitchLen: stitchLenInput.value,
      stitchGap: stitchGapInput.value,
      angle: angleInput.value,
      simplify: simplifyInput.value,
      mode: stitchModeInput.value,
      bgOpacity: bgOpacityInput.value,
      exportScale: exportScaleInput.value
    };
    log('ุทูุจ ูุนุงููุฉ (ุงูุนุงูู ุณูุนุงูุฌ ุงูุตูุฑุฉ ุจููุณ ุงูุงุนุฏุงุฏุงุช)');
    worker.postMessage({ type:'process', dataURL, settings });
  }catch(e){
    log('ุฎุทุฃ ูุฑุงุกุฉ ุงูููู: ' + e);
    hideSpinner();
  }
});

log('ุฌุงูุฒ โ ุงุฎุชุฑ ุตูุฑุฉ ูุงุถุบุท "ุชูููุฏ" ุฃู "ูุนุงููุฉ"');
</script>
</body>
</html>
